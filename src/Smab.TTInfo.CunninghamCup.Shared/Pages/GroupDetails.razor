@page "/group"
@page "/group/{GroupName}"
@inject ITournamentService _tournamentService
@inject IHostEnvironment env
@inject NavigationManager navigationManager

<PageTitle>@(GroupName is not null ? GroupName : "Groups") - @tournament?.Name</PageTitle>
<h1>@tournament?.Name</h1>

@if (tournament?.Groups.Count > 0) {
	<nav class="mb-3 container-fluid">
	@if (RendererInfo.IsInteractive) {
		<label for="groupSelector" class="form-label">Select Group:</label>
		<select id="groupSelector" class="form-select" @onchange="OnGroupChanged" value="@GroupName">
			@if (GroupName is null) {
				<option value=" " selected>Select a group</option>
			}
			@foreach (Group g in tournament.Groups) {
				<option value="@g.Name" selected="@(g.Name == GroupName)">@g.Name</option>
			}
		</select>
	} else {
		@foreach (Group g in tournament.Groups) {
			<a class="btn btn-primary @((g.Name == GroupName) ? "disabled" : null)"
				role="button"
				href="group/@g.Name"
				aria-disabled="@((g.Name == GroupName) ? "true" : null)"
			>@g.Name</a>
		}
	}
	</nav>
}
@if (tournament?.Groups.Count == 0) {
	<div class="alert alert-info">
		<h3>No Groups Available</h3>
		<p>Groups have not been drawn yet.</p>
	</div>
	<CanEdit>
		<table>
			<tr>
				<td class="pe-3">No of players: <strong>@tournament.ActivePlayers.Count</strong></td>
				<td>Group size<input type="number" title="Group size" @bind-value="groupSize" class="form-control d-inline m-1" /></td>
				<td><button type="button" class="btn btn-success ms-3" @onclick="DrawGroups">Draw Groups</button></td>
			</tr>
		</table>
	</CanEdit>
} else if (GroupName is null) {
	<p></p>
} else if ((group is null || players is null)) {
	<p>Group or player data not loaded.</p>
} else {
	<div class="group-header">
		<h2>@group.Name</h2>
		<span class="badge text-bg-info">Round Robin</span>
		<span class="badge bg-secondary">Size @group.Players.Count</span>
		@if (env.IsDevelopment())
		{
			<CanEdit>
					<button title="Reset all match scores" class="btn btn-sm btn-warning float-end" @onclick="ResetGroup">Reset</button>
					<button title="Random match scores" class="btn btn-sm btn-warning float-end mx-3" @onclick="CompleteWithRandomScores">
						<svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#shuffle" /></svg>
					</button>
			</CanEdit>
		}
	</div>

	<h3>Summary</h3>
	<table class="table table-dark table-striped">
		<thead>
			<tr>
				<th>#</th>
				<th>Player</th>
				<th>PL</th>
				<th>M</th>
				<th>S</th>
				<th>GM</th>
				<th>H</th>
			</tr>
		</thead>
		<tbody>
			@foreach ((int i, GroupPlayerSummary summary) in group.GroupPositions.Index()) {
				Player player = players.ContainsKey(summary.PlayerId) ? players[summary.PlayerId] : new Player(summary.PlayerId, "Unknown");
				<tr>
					<td>@(i + 1)</td>
					<td>@player.Name (@player.Handicap)</td>
					<td>@summary.Played</td>
					<td>@summary.MatchWins-@summary.MatchLosses</td>
					<td>@summary.SetsFor-@summary.SetsAgainst</td>
					<td>@summary.PointsFor-@summary.PointsAgainst</td>
					<td>
						@foreach (Match match in group.Matches.Where(m => summary.PlayerId == m.PlayerA || summary.PlayerId == m.PlayerB)) {
							@if (match.IsCompleted) {
								@if (match.PlayerA == summary.PlayerId) {
									@if (match.IsPlayerAWin) {
										<span class="badge bg-success rounded-pill">W</span>
									} else {
										<span class="badge bg-danger rounded-pill">L</span>
									}
								}
								@if (match.PlayerB == summary.PlayerId) {
									@if (match.IsPlayerBWin) {
										<span class="badge bg-success rounded-pill">W</span>
									} else {
										<span class="badge bg-danger rounded-pill">L</span>
									}
								}
							}
						}
					</td>
				</tr>
			}
		</tbody>
	</table>

	<h3>Matches</h3>
	<table class="table table-dark table-bordered">
		<thead>
			<tr>
				<th>#</th>
				<th>Player A</th>
				<th>Player B</th>
				@if (group.Matches.Any(m => m.IsCompleted))
				{
					<th>Sets</th>
					<th>Score</th>
				}
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < group.Matches.Count; i++) {
				int matchNo = i;
				Match match = group.Matches[i];
				Player playerA = players.ContainsKey(match.PlayerA) ? players[match.PlayerA] : new Player(match.PlayerA, "Unknown");
				Player playerB = players.ContainsKey(match.PlayerB) ? players[match.PlayerB] : new Player(match.PlayerB, "Unknown");
				string score = match.Result is not null
				? $"{string.Join(", ", match.Result.Sets.Select(set => $"{set.PlayerAScore}-{set.PlayerBScore}"))}"
				: "";
				<tr>
					<td>@(i + 1)</td>
					<td>@playerA.Name (@match.PlayerAStart)</td>
					<td>@playerB.Name (@match.PlayerBStart)</td>
					@if (match.IsCompleted) {
						<td>@($"{match.PlayerASets}-{match.PlayerBSets}")</td>
						<td>@score
						<CanEdit>
							<button class="btn btn-primary btn-sm float-end" @onclick="() => EditMatch(matchNo)">Edit</button>
							@if (env.IsDevelopment()) {
								<button class="btn btn-sm btn-warning float-end" @onclick="() => CompleteMatchWithRandomScores(matchNo)">
									<svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#shuffle" /></svg>
								</button>
							}
						</CanEdit>
						</td>
					}
				</tr>
				<CanEdit>
					@if (editingMatchNo == matchNo) {
					<tr>
						<td colspan="6">
							<MatchEditor Match="@match" OnSave="OnMatchSaveAsync" OnCancel="CancelEditMatch" />
						</td>
					</tr>
					}
				</CanEdit>
			}
		</tbody>
	</table>
}

@code {
	[Parameter] public string GroupName { get; set; } = string.Empty;

	[PersistentState]
	public Group? group { get; set; }
	private Dictionary<PlayerId, Player>? players;

	[PersistentState]
	public Tournament? tournament { get; set; }

	private int groupSize = 4;
	private int? editingMatchNo = null;

	protected override void OnInitialized()
	{
		tournament ??= _tournamentService.GetTournament();
		group ??= tournament.Groups.FirstOrDefault(g => string.Equals(g.Name, GroupName, StringComparison.OrdinalIgnoreCase));
		players = tournament.Players;
	}

	private void DrawGroups(MouseEventArgs args)
	{
		_tournamentService.DrawGroups(groupSize);
		_tournamentService.SaveTournamentToJsonAsync();
		navigationManager.NavigateTo($"/group", true);
	}

	private void OnGroupChanged(ChangeEventArgs e)
	{
		string selectedGroup = e.Value?.ToString() ?? string.Empty;
		if (!string.Equals(selectedGroup, GroupName, StringComparison.OrdinalIgnoreCase)) {
			// Navigate to the selected group page
			navigationManager.NavigateTo($"/edit/group/{selectedGroup}");
		}
	}

	private void CompleteWithRandomScores() => group = _tournamentService.CompleteGroupWithRandomResults(group!.Name);
	private void CompleteMatchWithRandomScores(int matchNo) => group = _tournamentService.CompleteMatchWithRandomScores(group!.Name, matchNo);
	private void ResetGroup() => group = _tournamentService.ResetGroup(group!.Name);

	private void EditMatch(int matchNo)
	{
		editingMatchNo = matchNo;
	}

	private void CancelEditMatch()
	{
		editingMatchNo = null;
	}

	private async Task OnMatchSaveAsync(Match updatedMatch)
	{
		if (group is not null && editingMatchNo is not null)
		{
			group.Matches[editingMatchNo.Value] = updatedMatch;
		}
		await InvokeAsync(StateHasChanged);
		if (tournament is not null)
		{
			_tournamentService.AddOrUpdateTournament(tournament);
		}
		editingMatchNo = null;
	}
}
