@page "/group"
@page "/group/{GroupName}"
@inject ITournamentService _tournamentService
@inject IHostEnvironment env
@inject NavigationManager navigationManager

<PageTitle>@(GroupName is not null ? GroupName : "Groups") - @tournament?.Name</PageTitle>
<h2>@tournament?.Name</h2>

@if (tournament?.Groups.Count > 0) {
	@if (false && RendererInfo.IsInteractive) {
		<nav class="mb-3 container-fluid">
			<label for="groupSelector" class="form-label">Select Group:</label>
			<select id="groupSelector" class="form-select" @onchange="OnGroupChanged" value="@GroupName">
				@if (GroupName is null) {
					<option value=" " selected>Select a group</option>
				}
				@foreach (Group g in tournament.Groups) {
					<option value="@g.Name" selected="@(g.Name == GroupName)">@g.Name</option>
				}
			</select>
		</nav>
	} else if (GroupName is null) {
		<div class="container-fluid d-flex justify-content-center">
			<div>
				@for (int i = 0; i < tournament.Groups.Count; i++) {
					int groupNo = i;
					Group group = tournament.Groups[i];
					<h3>
						<CanEdit>
							<CantEdit>
								<a class="btn btn-primary " role="button" href="group/@group.Name">@group.Name</a>
								<span class="fs-6">@group.ScheduledTime?.ToShortTimeString()</span>
							</CantEdit>
						</CanEdit>
						<CanEdit>
							<a class="btn btn-primary " role="button" href="edit/group/@group.Name">@group.Name</a>
							<span class="fs-6">@group.ScheduledTime?.ToShortTimeString()</span>
							<button class="btn btn-primary btn-sm" @onclick="() => EditTimeOfGroup(groupNo)"><svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#pencil" /></svg></button>
							@if (groupNo == editingScheduledTimeNo)
							{
								<span>
									<input type="time" class="form-control d-inline ms-2" @bind-value="editScheduledTime" />
									<button type="button" class="btn btn-sm btn-success ms-2" @onclick="() => SaveScheduledTime(groupNo)">Set Time</button>
								</span>
							}
						</CanEdit>
					</h3>

					@foreach (PlayerId playerId in group.Players) {
						Player player = tournament.GetPlayer(playerId);
						<div data-withdrawn="@player.WithDrawn">@playerId.DisplayName (@tournament.GetPlayer(playerId).Handicap)</div>
					}
				}
			</div>
		</div>

	} else {
		<nav class="mb-3 container-fluid">
			@foreach (Group g in tournament.Groups) {
				<a class="btn btn-primary m-1 @((g.Name == GroupName) ? "disabled" : null)"
				   role="button"
				   href="group/@g.Name"
				   aria-disabled="@((g.Name == GroupName) ? "true" : null)">@g.Name</a>
			}
		</nav>
	}
}
@if (tournament?.Groups.Count == 0) {
	<div class="alert alert-info">
		<h3>No Groups Available</h3>
		<p>Groups have not been drawn yet.</p>
	</div>
	<CanEdit>
		<table>
			<tr>
				<td class="pe-3">No of players <input type="number" title="Group size" value="@tournament.ActivePlayers.Count" class="form-control d-inline m-1" disabled /></td>
				<td>Group size<input type="number" title="Group size" @bind-value="groupSize" class="form-control d-inline m-1" /></td>
				<td><button type="button" class="btn btn-success ms-3" @onclick="DrawGroups">Draw Groups</button></td>
			</tr>
		</table>
	</CanEdit>
} else if (GroupName is null) {
	@* @foreach (Group group in tournament?.Groups ?? []) {
		<h3><a class="btn btn-primary m-1" role="button" href="group/@group.Name">@group.Name</a></h3>
		@foreach (PlayerId playerId in group.Players)
		{
			<div>@playerId.DisplayName</div>
		}
	} *@
} else if ((group is null || players is null)) {
	<p>Group or player data not loaded.</p>
} else {
	<div class="group-header">
		<h2>@group.Name</h2>
		<span class="badge text-bg-info">Round Robin</span>
		<span class="badge bg-secondary">Size @group.Players.Count</span>
		@if (env.IsDevelopment()) {
			<CanEdit>
				<button title="Reset all match scores" class="btn btn-sm btn-warning float-end" @onclick="ResetGroup">Reset</button>
				<button title="Random match scores" class="btn btn-sm btn-warning float-end mx-3" @onclick="CompleteWithRandomScores">
					<svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#shuffle" /></svg>
				</button>
			</CanEdit>
		}
	</div>

	<h3>Summary</h3>
	<table id="summary" class="table table-striped">
		<thead>
			<tr>
				<th>#</th>
				<th>Player</th>
				<th>PL</th>
				<th>M</th>
				<th>S</th>
				<th>GM</th>
				<th>H</th>
			</tr>
		</thead>
		<tbody>
			@foreach ((int i, GroupPlayerSummary summary) in group.GroupPositions.Index()) {
				Player player = players.ContainsKey(summary.PlayerId) ? players[summary.PlayerId] : new Player(summary.PlayerId, "Unknown");
				<tr data-withdrawn="@player.WithDrawn">
					<td>@(i + 1)</td>
					<td>@player.Name (@player.Handicap)</td>
					<td>@summary.Played</td>
					<td>@summary.MatchWins-@summary.MatchLosses</td>
					<td>@summary.SetsFor-@summary.SetsAgainst</td>
					<td>@summary.PointsFor-@summary.PointsAgainst</td>
					<td>
						@foreach (Match match in group.Matches.Where(m => summary.PlayerId == m.PlayerA || summary.PlayerId == m.PlayerB)) {
							@if (match.IsCompleted) {
								@if (match.PlayerA == summary.PlayerId) {
									@if (match.IsPlayerAWin) {
										<span class="badge bg-success rounded-pill">W</span>
									} else {
										<span class="badge bg-danger rounded-pill">L</span>
									}
								}
								@if (match.PlayerB == summary.PlayerId) {
									@if (match.IsPlayerBWin) {
										<span class="badge bg-success rounded-pill">W</span>
									} else {
										<span class="badge bg-danger rounded-pill">L</span>
									}
								}
							}
						}
					</td>
				</tr>
			}
		</tbody>
	</table>

	<h3>Matches</h3>
	<table id="matches" class="table table-bordered">
		<thead>
			<tr>
				<th>#</th>
				<th>Player A</th>
				<th>Player B</th>
				@if (group.Matches.Any(m => m.IsCompleted)) {
					<th>Sets</th>
					<th>Score</th>
				}
				<CanEdit><th></th></CanEdit>
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < group.Matches.Count; i++) {
				int matchNo = i;
				Match match = group.Matches[i];
				Player playerA = players.ContainsKey(match.PlayerA) ? players[match.PlayerA] : new Player(match.PlayerA, "Unknown");
				Player playerB = players.ContainsKey(match.PlayerB) ? players[match.PlayerB] : new Player(match.PlayerB, "Unknown");
				string score = match.Result is not null
				? $"{string.Join(", ", match.Result.Sets.Select(set => $"{set.PlayerAScore}-{set.PlayerBScore}"))}"
				: "";
				<tr>
					<td>@(i + 1)</td>
					<td data-winner="@match.IsPlayerAWin">@playerA.Name (@match.PlayerAStart)</td>
					<td data-winner="@match.IsPlayerBWin">@playerB.Name (@match.PlayerBStart)</td>
					@if (group.Matches.Any(m => m.IsCompleted)) {
						<td>@($"{match.PlayerASets}-{match.PlayerBSets}")</td>
						<td>@score</td>
					}
					<CanEdit>
						<td class="edit">
							<button class="btn btn-primary btn-sm" @onclick="() => EditMatch(matchNo)"><svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#pencil" /></svg></button>
							@if (env.IsDevelopment()) {
								<button class="btn btn-sm btn-warning" @onclick="() => CompleteMatchWithRandomScores(matchNo)">
									<svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#shuffle" /></svg>
								</button>
							}
						</td>
					</CanEdit>
				</tr>
				<CanEdit>
					@if (editingMatchNo == matchNo) {
						<tr>
							<td colspan="6">
								<MatchEditor Match="@match" OnSave="OnMatchSaveAsync" OnCancel="CancelEditMatch" />
							</td>
						</tr>
					}
				</CanEdit>
			}
		</tbody>
	</table>
}

@code {
	[Parameter] public string GroupName { get; set; } = string.Empty;

	[PersistentState]
	public Group? group { get; set; }
	private Dictionary<PlayerId, Player>? players;

	[PersistentState]
	public Tournament? tournament { get; set; }

	private int groupSize = 4;
	private int? editingMatchNo = null;
	private int? editingScheduledTimeNo = null;
	private DateTime? editScheduledTime;

	protected override void OnInitialized()
	{
		tournament ??= _tournamentService.GetTournament();
		group ??= tournament.Groups.FirstOrDefault(g => string.Equals(g.Name, GroupName, StringComparison.OrdinalIgnoreCase));
		players = tournament.Players;
	}

	private void DrawGroups(MouseEventArgs args)
	{
		_tournamentService.DrawGroups(groupSize);
		_tournamentService.SaveTournamentToJsonAsync();
		navigationManager.NavigateTo($"/group", true);
	}

	private void OnGroupChanged(ChangeEventArgs e)
	{
		string selectedGroup = e.Value?.ToString() ?? string.Empty;
		if (!string.Equals(selectedGroup, GroupName, StringComparison.OrdinalIgnoreCase)) {
			// Navigate to the selected group page
			navigationManager.NavigateTo($"/edit/group/{selectedGroup}");
		}
	}

	private void CompleteWithRandomScores() => group = _tournamentService.CompleteGroupWithRandomResults(group!.Name);
	private void CompleteMatchWithRandomScores(int matchNo) => group = _tournamentService.CompleteMatchWithRandomScores(group!.Name, matchNo);
	private void ResetGroup() => group = _tournamentService.ResetGroup(group!.Name);

	private void EditTimeOfGroup(int groupNo)
	{
		editScheduledTime = tournament!.Groups[groupNo].ScheduledTime;
		editingScheduledTimeNo = groupNo;
	}

	private void EditMatch(int matchNo)
	{
		editingMatchNo = matchNo;
	}

	private void CancelEditMatch()
	{
		editingMatchNo = null;
	}

	private async Task OnMatchSaveAsync(Match updatedMatch)
	{
		if (group is not null && editingMatchNo is not null) {
			group.Matches[editingMatchNo.Value] = updatedMatch;
		}
		await InvokeAsync(StateHasChanged);
		if (tournament is not null) {
			_tournamentService.AddOrUpdateTournament(tournament);
		}
		editingMatchNo = null;
	}

	private void SaveScheduledTime(int groupNo)
	{
		Group group = tournament!.Groups[groupNo];
		if (editScheduledTime is not null)
		{
			group = group with { ScheduledTime = new DateTime( tournament.Date, TimeOnly.FromDateTime((DateTime)editScheduledTime)) };
			tournament.Groups[groupNo] = group;
			StateHasChanged();
		}

		editingScheduledTimeNo = null;
	}
}
