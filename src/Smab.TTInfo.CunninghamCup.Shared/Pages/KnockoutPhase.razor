@page "/knockout"
@page "/edit/knockout/{KnockoutName}"
@using Smab.TTInfo.CunninghamCup.Shared.Models
@inject ITournamentService _tournamentService

<PageTitle>Knockout Phase - @tournament?.Name</PageTitle>

<h2>
	@(tournament?.KnockoutStage?.Name ?? "Knockout Phase" )
	<CanEdit>
		@if (tournament?.KnockoutStage is null) {
			<button class="btn btn-success ms-4" @onclick="DrawMainKnockout">Draw Main Knockout</button>
		} else {
			<button class="btn btn-success ms-4" @onclick="UpdateMainKnockout">Update Main Knockout</button>
		}
		@if (tournament?.ConsolationStage is null) {
			<button class="btn btn-success ms-4" @onclick="DrawConsolation">Draw Consolation</button>
		} else {
			<button class="btn btn-success ms-4" @onclick="UpdateConsolation">Update consolation</button>
		}
	</CanEdit>
</h2>
@if (tournament is null || tournament.KnockoutStage is null) {
	<div class="alert alert-info">
		<h3>Not drawn yet</h3>
		<p>The knockout phase hasn't been drawn yet.</p>
	</div>
	<Qualifiers />
} else {
	@for (int roundIdx = 0; roundIdx < tournament.KnockoutStage.Rounds.Count; roundIdx++) {
		int roundNo = roundIdx;
		KnockoutRound round = tournament.KnockoutStage.Rounds[roundNo];
		<div class="card mb-4">
			<div class="card-header">
				<strong>@round.Type.ToFriendlyString()</strong>
			</div>
			<div class="card-body">
				<table id="matches" class="table">
					@* <thead>
						<tr>
							<th>#</th>
							<th>Player A</th>
							<th>Player B</th>
							<th>Score</th>
							<CanEdit>
								<th>Edit</th>
							</CanEdit>
						</tr>
					</thead> *@
					<tbody>
						@for (int i = 0; i < round.Matches.Count; i++) {
							int matchNo = i;
							Match match = round.Matches[i];
							Player? playerA = match.PlayerA.IsPlayer ? tournament.GetPlayer(match.PlayerA) : null;
							Player? playerB = match.PlayerB.IsPlayer ? tournament.GetPlayer(match.PlayerB) : null;
							string score = match.Result is not null
							? $"{string.Join(", ", match.Result.Sets.Select(set => $"{set.PlayerAScore}-{set.PlayerBScore}"))}"
							: "";
							<tr>
								<td>@(i + 1)</td>
								<td data-winner="@match.IsPlayerAWin">
									@(match.PlayerA.IsPlaceHolder && char.IsAsciiDigit($"{match.PlayerA}"[1]) ? "" : match.PlayerA.DisplayName)
									@(playerA is not null ? $"({@match.PlayerAStart})" : "")
								</td>
								<td data-winner="@match.IsPlayerBWin">
									@(match.PlayerB.IsPlaceHolder && char.IsAsciiDigit($"{match.PlayerB}"[1]) ? "" : match.PlayerB.DisplayName)
									@(playerB is not null ? $"({@match.PlayerBStart})" : "")
								</td>
								<td>@(match.IsCompleted ? $"{match.PlayerASets}-{match.PlayerBSets}" : "")</td>
								<td>@score</td>
								<CanEdit>
									<td>
										@if (match.PlayerA.IsPlayer && match.PlayerB.IsPlayer) {
											<button class="btn btn-primary btn-sm float-end" @onclick="() => EditMatch(roundNo, matchNo)">Edit</button>
											<button class="btn btn-sm btn-warning float-end" @onclick="() => CompleteMatchWithRandomScores(roundNo, matchNo)">
												<svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#shuffle" /></svg>
											</button>
										}
									</td>
								</CanEdit>
							</tr>
							<CanEdit>
								@if (editingMatchNo == (roundNo, matchNo)) {
									<tr>
										<td colspan="6">
											<MatchEditor Match="@match" OnSave="OnMatchSaveAsync" OnCancel="CancelEditMatch" />
										</td>
									</tr>
								}
							</CanEdit>
						}
					</tbody>
				</table>
			</div>
		</div>
	}
}

@code {
	[Parameter]
	public string? KnockoutName { get; set; } = null;

	[PersistentState]
	public Tournament? tournament { get; set; }

	private Dictionary<PlayerId, Player>? players;
	private (int RoundNo, int MatchNo)? editingMatchNo = null;

	protected override void OnInitialized()
	{
		tournament ??= _tournamentService.GetTournament();
		players = tournament.Players;
	}


	private void EditMatch(int roundNo, int matchNo) => editingMatchNo = (roundNo, matchNo);
	private void CancelEditMatch() => editingMatchNo = null;

	private async Task OnMatchSaveAsync(Match updatedMatch)
	{
		// if (group is not null && editingMatchNo is not null) {
		// 	group.Matches[editingMatchNo.Value] = updatedMatch;
		// }

		(int roundNo, int matchNo) = editingMatchNo!.Value;
		tournament?.KnockoutStage!.Rounds[roundNo].Matches[matchNo] = updatedMatch;
		await InvokeAsync(StateHasChanged);
		if (tournament is not null) {
			_tournamentService.AddOrUpdateTournament(tournament);
		}

		editingMatchNo = null;
	}

	// private void CompleteMatchWithRandomScores(int matchNo) => group = _tournamentService.CompleteMatchWithRandomScores(group!.Name, matchNo);
	private void CompleteMatchWithRandomScores(int roundNo, int matchNo)
	{
		Match match = tournament!.KnockoutStage!.Rounds[roundNo].Matches[matchNo];
		match = TournamentService.SetRandomResult(match);
		tournament.KnockoutStage.Rounds[roundNo].Matches[matchNo] = match;
		_tournamentService.AddOrUpdateTournament(tournament);
		StateHasChanged();
	}

	private void UpdateMainKnockout()
	{
		tournament = _tournamentService.UpdateKnockoutPhases();
		StateHasChanged();
	}

	private void DrawMainKnockout()
	{
		tournament = _tournamentService.DrawKnockoutStage();
		tournament = _tournamentService.UpdateKnockoutPhases();
		StateHasChanged();
	}

	private void UpdateConsolation()
	{
		// tournament = _tournamentService.UpdateKnockoutPhases();
		// StateHasChanged();
	}

	private void DrawConsolation()
	{
		// tournament = _tournamentService.DrawKnockoutStage();
		// tournament = _tournamentService.UpdateKnockoutPhases();
		// StateHasChanged();
	}
}
