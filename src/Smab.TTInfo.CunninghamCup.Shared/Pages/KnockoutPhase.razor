@page "/knockout"
@page "/edit/knockout/{KnockoutName}"
@using Smab.TTInfo.CunninghamCup.Shared.Models
@inject ITournamentService _tournamentService

<PageTitle>Knockout Phase - @(tournament?.Name ?? "Cunningham Cup")</PageTitle>

<h1>
	@(tournament?.Name ?? "Knockout Phase")
	<CanEdit>
		@if (tournament?.KnockoutStage is null) {
			<button class="btn btn-success ms-4" @onclick="DrawMainKnockout">Draw Main Knockout</button>
		} else {
			<button class="btn btn-success ms-4" @onclick="UpdateMainKnockout">Update Main Knockout</button>
		}
		@if (tournament?.ConsolationStage is null) {
			<button class="btn btn-success ms-4" @onclick="DrawConsolation">Draw Consolation</button>
		} else {
			<button class="btn btn-success ms-4" @onclick="UpdateConsolation">Update consolation</button>
		}
	</CanEdit>
</h1>

<div>
	<div>
		@if (tournament is null || knockoutStages.All(ks => ks is null)) {
			<Qualifiers Positions="[0, 1]" Title="Qualifiers for Main Knockout" />
			<Qualifiers Positions="[2, 3]" Title="Qualifiers for Consolation" />
			<div class="alert alert-info">
				<h3>Not drawn yet</h3>
				<p>The knockout draw hasn't been made yet.</p>
			</div>
		} else {
			<div class="accordian">
				@foreach (KnockoutStage knockoutStage in knockoutStages.Where(ks => ks is not null).Select(ks => (KnockoutStage)ks!)) {
					<div>
						<h3 class="accordian-header">@knockoutStage.Name</h3>
						@for (int roundIdx = knockoutStage.Rounds.Count - 1; roundIdx >= 0; roundIdx--) {
							int roundNo = roundIdx;
							KnockoutRound round = knockoutStage.Rounds[roundNo];
							@if (roundNo == 0 || round.Matches.Any(m => m.PlayerA.IsPlayer || m.PlayerB.IsPlayer)) {
								<div class="card mb-4">
									<div class="card-header">
										<strong>@round.Type.ToFriendlyString()</strong>
									</div>
									<div class="card-body">
										<table id="matches" class="table">
											<tbody>
												@for (int i = 0; i < round.Matches.Count; i++) {
													int matchNo = i;
													Match match = round.Matches[i];
													Player? playerA = match.PlayerA.IsPlayer ? tournament.GetPlayer(match.PlayerA) : null;
													Player? playerB = match.PlayerB.IsPlayer ? tournament.GetPlayer(match.PlayerB) : null;
													string score = match.Result is not null
													? $"{string.Join(", ", match.Result.Sets.Select(set => $"{set.PlayerAScore}-{set.PlayerBScore}"))}"
													: "";
													<tr>
														<td>@(i + 1)</td>
														<td data-winner="@match.IsPlayerAWin">
															@(match.PlayerA.IsPlaceHolder && char.IsAsciiDigit($"{match.PlayerA}"[1]) ? "" : match.PlayerA.DisplayName)
															@(playerA is not null ? $"({@match.PlayerAStart})" : "")
														</td>
														<td data-winner="@match.IsPlayerBWin">
															@(match.PlayerB.IsPlaceHolder && char.IsAsciiDigit($"{match.PlayerB}"[1]) ? "" : match.PlayerB.DisplayName)
															@(playerB is not null ? $"({@match.PlayerBStart})" : "")
														</td>
														<td>@(match.IsCompleted ? $"{match.PlayerASets}-{match.PlayerBSets}" : "")</td>
														<td>@score</td>
														<CanEdit>
															<td>
																@if (match.PlayerA.IsPlayer && match.PlayerB.IsPlayer) {
																	<button class="btn btn-primary btn-sm float-end" @onclick="() => EditMatch(knockoutStage, roundNo, matchNo)">Edit</button>
																	<button class="btn btn-sm btn-warning float-end" @onclick="() => CompleteMatchWithRandomScores(knockoutStage, roundNo, matchNo)">
																		<svg class="bi" height="16" width="16" fill="currentColor"><use xlink:href="bootstrap-icons.svg#shuffle" /></svg>
																	</button>
																}
															</td>
														</CanEdit>
													</tr>
													<CanEdit>
														@if (editingMatchNo == (knockoutStage, roundNo, matchNo)) {
															<tr>
																<td colspan="6">
																	<MatchEditor Match="@match" OnSave="OnMatchSaveAsync" OnCancel="CancelEditMatch" />
																</td>
															</tr>
														}
													</CanEdit>
												}
											</tbody>
										</table>
									</div>
								</div>
							}
						}
					</div>
				}
			</div>
		}
	</div>
</div>

@code {
	[Parameter]
	public string? KnockoutName { get; set; } = null;

	[PersistentState]
	public Tournament? tournament { get; set; }

	private List<KnockoutStage?> knockoutStages = [];
	private Dictionary<PlayerId, Player>? players;
	private (KnockoutStage knockoutStage, int RoundNo, int MatchNo)? editingMatchNo = null;

	protected override void OnInitialized()
	{
		tournament ??= _tournamentService.GetTournament();
		players = tournament.Players;
		knockoutStages = [tournament.KnockoutStage, tournament.ConsolationStage];
	}


	private void EditMatch(KnockoutStage knockoutStage, int roundNo, int matchNo) => editingMatchNo = (knockoutStage, roundNo, matchNo);
	private void CancelEditMatch() => editingMatchNo = null;

	private async Task OnMatchSaveAsync(Match updatedMatch)
	{
		(KnockoutStage knockoutStage, int roundNo, int matchNo) = editingMatchNo!.Value;
		knockoutStage!.Rounds[roundNo].Matches[matchNo] = updatedMatch;
		await InvokeAsync(StateHasChanged);
		if (tournament is not null) {
			_tournamentService.AddOrUpdateTournament(tournament);
			_ = _tournamentService.LogToAuditFile($"Match updated: {updatedMatch}");
		}

		editingMatchNo = null;
	}

	private void CompleteMatchWithRandomScores(KnockoutStage knockoutStage, int roundNo, int matchNo)
	{
		Match match = knockoutStage.Rounds[roundNo].Matches[matchNo];
		match = TournamentService.SetRandomResult(match);
		knockoutStage.Rounds[roundNo].Matches[matchNo] = match;
		StateHasChanged();
	}

	private void UpdateMainKnockout()
	{
		tournament = _tournamentService.UpdateMainKnockoutRounds();
		_tournamentService.AddOrUpdateTournament(tournament!);
		StateHasChanged();
	}

	private async Task DrawMainKnockout()
	{
		await _tournamentService.SaveTournamentToJsonAsync("before main knockout draw");
		tournament = _tournamentService.DrawMainKnockoutStage();
		tournament = _tournamentService.UpdateMainKnockoutRounds();
		_tournamentService.AddOrUpdateTournament(tournament!);
		_ = _tournamentService.LogToAuditFile($"Draw Main Knockout: {tournament?.KnockoutStage}");
		await _tournamentService.SaveTournamentToJsonAsync("after main knockout draw");
		StateHasChanged();
	}

	private void UpdateConsolation()
	{
		tournament = _tournamentService.UpdateConsolationRounds();
		_tournamentService.AddOrUpdateTournament(tournament!);
		StateHasChanged();
	}

	private async Task DrawConsolation()
	{
		await _tournamentService.SaveTournamentToJsonAsync("before consolation draw");
		tournament = _tournamentService.DrawConsolationStage();
		tournament = _tournamentService.UpdateConsolationRounds();
		_tournamentService.AddOrUpdateTournament(tournament!);
		_ = _tournamentService.LogToAuditFile($"Draw Consolation: {tournament?.ConsolationStage}");
		await _tournamentService.SaveTournamentToJsonAsync("after consolation draw");
		StateHasChanged();
	}
}
