@using Smab.TTInfo.CunninghamCup.Shared.Models
@using System.ComponentModel.DataAnnotations

<EditForm Model="editModel" OnValidSubmit="HandleValidSubmit" autocomplete="off">
	<DataAnnotationsValidator />
	<div class="card mt-2 mb-2">
		<div class="card-body">
			@* <h5 class="card-title">@Match.PlayerA.DisplayName vs @Match.PlayerB.DisplayName</h5> *@
			<div>
				<label class="player-label">@Match.PlayerA.DisplayName</label>
				@for (int i = 0; i < MAX_SETS; i++) {
					int setNo = i;
					<InputNumber @bind-Value="editModel.PlayerAScores[setNo]" min="0" max="30" class="form-control d-inline score" tabindex="@((i * 2) + 1)" />
				}
			</div>
			<div>
				<label class="player-label">@Match.PlayerB.DisplayName</label>
				@for (int i = 0; i < MAX_SETS; i++) {
					int setNo = i;
					<InputNumber @bind-Value="editModel.PlayerBScores[setNo]" min="0" max="30" class="form-control d-inline score" tabindex="@((i * 2) + 1)" />
				}
			</div>
			<div>
				<label>Notes:</label>
				<InputText @bind-Value="editModel.Notes" class="form-control" tabindex="7" />
			</div>
			<CustomValidation @ref="customValidation" />
			<ValidationSummary />
			<div class="mt-2">
				<button type="submit" class="btn btn-success btn-sm me-2" tabindex="8">Save</button>
				<button type="button" class="btn btn-warning btn-sm me-2" tabindex="9" @onclick="Reset">Reset</button>
				<button type="button" class="btn btn-secondary btn-sm" tabindex="9" @onclick="() => OnCancel.InvokeAsync()">Cancel</button>
			</div>
		</div>
	</div>
</EditForm>

@code {
	private const int MAX_SETS = 3;
	[Parameter] public Match Match { get; set; } = default!;
	[Parameter] public Func<Match, Task>? OnSave { get; set; }
	[Parameter] public EventCallback OnCancel { get; set; }
	[Parameter] public Func<Match, Task>? OnReset { get; set; }

	private CustomValidation? customValidation;
	private MatchEditModel editModel = new();

	protected override void OnInitialized()
	{
		List<Set> sets = Match.Result?.Sets ?? [];
		editModel.PlayerAScores = [.. sets.Select(s => s.PlayerAScore)];
		editModel.PlayerBScores = [.. sets.Select(s => s.PlayerBScore)];
		while (editModel.PlayerAScores.Count < MAX_SETS) editModel.PlayerAScores.Add(0);
		while (editModel.PlayerBScores.Count < MAX_SETS) editModel.PlayerBScores.Add(0);
		editModel.Notes = Match.Result?.Notes;
	}

	private async Task HandleValidSubmit()
	{
		customValidation?.ClearErrors();

		Dictionary<string, List<string>> errors = [];
		Result? result = default;

		List<Set> sets = [];
		for (int i = 0; i < MAX_SETS; i++) {
			if (editModel.PlayerAScores[i] != 0 || editModel.PlayerBScores[i] != 0) {
				sets.Add(new Set(editModel.PlayerAScores[i], editModel.PlayerBScores[i]));
			}
		}

		if (sets.Count is > 0 and < 2) {
			errors.Add("Sets", ["There must be at least 2 sets entered"]);
		} else if (sets.Count != 0) {
			result = new(sets, editModel.Notes);
			if (result.IsNotCompleted) {
				errors.Add("SetsValid", ["Not a valid result, doesn't appear to be a completed result"]);
			}

			if (int.Abs(result.PlayerASets - result.PlayerBSets) is < 1 or > 2) {
				errors.Add("Sets", [$"Difference in sets of {int.Abs(result.PlayerASets - result.PlayerBSets)} is not valid"]);
			}

			List<string> setErrors = [];
			for (int i = 0; i < result.Sets.Count; i++) {
				Set set = result.Sets[i];
				int setNo = i + 1;
				if (set.PlayerAScore < 21 && set.PlayerBScore < 21) {
					setErrors.Add($"Set {setNo} is not finished");
				}
				if ((set.PlayerAScore == 21 || set.PlayerBScore == 21) && int.Abs(set.PlayerAScore - set.PlayerBScore) < 2) {
					setErrors.Add($"Set {setNo} has a score with less than 2 points difference");
				}
				if ((set.PlayerAScore > 21 || set.PlayerBScore > 21) && int.Abs(set.PlayerAScore - set.PlayerBScore) != 2) {
					setErrors.Add($"Set {setNo} has a score with more than 2 points difference");
				}
				if (set.PlayerAScore > 30 || set.PlayerBScore > 30) {
					setErrors.Add($"Set {setNo} has a score greater than 30");
				}
			}

			if (setErrors.Any()) {
				errors.Add("SetsScores", setErrors);
			}
		}

		if (errors.Any()) {
			customValidation?.DisplayErrors(errors);
		} else {
			Match updatedMatch = Match with { Result = result };
			if (OnSave is not null) {
				await OnSave.Invoke(updatedMatch);
			}
		}

	}

	private void Reset()
	{
		customValidation?.ClearErrors();

		Match = Match with { Result = null };

		OnInitialized();
		StateHasChanged();
	}

	public class MatchEditModel
	{
		[Required]
		public List<int> PlayerAScores { get; set; } = [];
		[Required]
		public List<int> PlayerBScores { get; set; } = [];
		public string? Notes { get; set; }
	}
}

